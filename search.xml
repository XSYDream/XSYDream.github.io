<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大创项目-水面清理船]]></title>
    <url>%2F2019%2F07%2F01%2F%E5%A4%A7%E5%88%9B%E9%A1%B9%E7%9B%AE-%E6%B0%B4%E9%9D%A2%E6%B8%85%E7%90%86%E8%88%B9%2F</url>
    <content type="text"><![CDATA[本次主要介绍本人最近的项目水面清理船人员分工废话不多说，直接贴上大创任务书的图片 这个作品的硬件比较简单 主要是图像处理部分，所以本文主要讲解视频图像处理部分下面的程序可以看到图像处理的结果&gt; # 导入所需模块 import cv2 as cv import collections import numpy as np import imutils import socket import time &gt; # 打开摄像头 url_s = &apos;http://192.168.1.1:8080/?action=stream&apos; cap = cv.VideoCapture(url_s ) &gt; # 创建一个socket: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) &gt; # 建立连接: s.connect((&apos;192.168.1.1&apos;, 2001)) &gt; &gt; &gt; while True: &gt; # 读取每一帧 &gt; _, frame = cap.read() &gt; # 重设图片尺寸以提高计算速度 &gt; frame = imutils.resize(frame, width=600) &gt; # 进行高斯模糊str1 = &apos;,&apos;.join(arr) &gt; blurred = cv.GaussianBlur(frame, (11, 11), 0) &gt; # 转换颜色空间到HSV &gt; hsv = cv.cvtColor(blurred, cv.COLOR_BGR2HSV) &gt; # 定义蓝色无图的HSV阈值 &gt; lower_red = np.array([20, 100, 100]) &gt; upper_red = np.array([220, 255, 255]) &gt; # 对图片进行二值化处理 &gt; mask = cv.inRange(hsv, lower_red, upper_red) &gt; # 腐蚀操作 &gt; mask = cv.erode(mask, None, iterations=2) &gt; # 膨胀操作，先腐蚀后膨胀以滤除噪声 &gt; mask = cv.dilate(mask, None, iterations=2) &gt; cv.imshow(&apos;yuantu&apos;, frame) &gt; cv.imshow(&apos;mask&apos;, mask) &gt; &gt; # 寻找图中轮廓 &gt; cnts = cv.findContours(mask.copy(), cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)[-2] &gt; &gt; # 如果存在至少一个轮廓则进行如下操作 &gt; if len(cnts) &gt; 0: &gt; # 找到面积最大的轮廓 &gt; c = max(cnts, key=cv.contourArea) &gt; # 使用最小外接圆圈出面积最大的轮廓 &gt; ((x, y), radius) = cv.minEnclosingCircle(c) &gt; # 计算轮廓的矩 &gt; M = cv.moments(c) &gt; # 计算轮廓的重心 &gt; center = (int(M[&quot;m10&quot;] / M[&quot;m00&quot;]), int(M[&quot;m01&quot;] / M[&quot;m00&quot;])) &gt; zuobiao=np.array(center) &gt; print(zuobiao) &gt; if zuobiao[1]&gt;240: &gt; s.send(b&apos;0&apos;) &gt; print(&apos;停&apos;) &gt; else: &gt; if zuobiao[0]&gt;400: &gt; s.send(b&apos;1&apos;) &gt; print(&apos;右&apos;) &gt; elif zuobiao[0]&lt;200: &gt; s.send(b&apos;2&apos;) &gt; print(&apos;左&apos;) &gt; elif 240&lt;zuobiao[0]&lt;400: &gt; s.send(b&apos;3&apos;) &gt; print(&apos;前&apos;) &gt; # 只处理尺寸足够大的轮廓 &gt; if radius &gt; 5: &gt; # 画出最小外接圆 &gt; cv.circle(frame, (int(x), int(y)), int(radius), (0, 255, 255), 2) &gt; # 画出重心 &gt; cv.circle(frame, center, 5, (0, 0, 255), -1) &gt; zuobiao=[] &gt; else: &gt; print(&apos;无图像&apos;) &gt; s.send(b&apos;4&apos;) &gt; cv.imshow(&apos;frame&apos;, frame) &gt; k = cv.waitKey(5) &amp; 0xFF &gt; if k == 27: &gt; break cap.release() cv.destroyAllWindows()下面的程序可以直接控制小船跑动&gt; from tkinter import * import cv2 as cv from PIL import Image, ImageTk &gt; import os import socket url_s = &gt; &apos;http://192.168.1.1:8080/?action=stream&apos; capture = &gt; cv.VideoCapture(url_s) &gt; # 创建一个socket: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) &gt; # # 建立连接: s.connect((&apos;192.168.1.1&apos;, 2001)) &gt; &gt; #摄像机设置 &gt; #0是代表摄像头编号，只有一个的话默认为0 &gt; &gt; &gt; def getframe(): &gt; ref,frame=capture.read() &gt; cv.imwrite(tempimagepath,frame) &gt; &gt; def closecamera(): &gt; capture.release() &gt; &gt; &gt; def getframe(): &gt; ref, frame = capture.read() &gt; cv.imwrite(tempimagepath, frame) &gt; &gt; &gt; def closecamera(): &gt; capture.release() &gt; &gt; &gt; # 界面相关 window_width = 640 window_height = 480 image_width = int(window_width * 0.6) image_height = int(window_height * 0.6) &gt; imagepos_x1 = int(window_width * 0.2) imagepos_y1 = int(window_height &gt; * 0.1) butpos_x1 = 250 butpos_y1 = 350 imagepos_x2 = int(window_width * 0.2) imagepos_y2 = int(window_height * 0.1) butpos_x2 = 250 butpos_y2 = 400 imagepos_x3 = int(window_width * 0.2) imagepos_y3 = &gt; int(window_height * 0.1) butpos_x3 = 100 butpos_y3 = 400 imagepos_x4 = &gt; int(window_width * 0.2) imagepos_y4 = int(window_height * 0.1) &gt; butpos_x4 = 400 butpos_y4 = 400 &gt; &gt; top = Tk() top.wm_title(&quot;face recognition&quot;) &gt; top.geometry(str(window_width) + &apos;x&apos; + str(window_height)) &gt; &gt; &gt; def tkImage(): &gt; ref, frame = capture.read() &gt; cvimage = cv.cvtColor(frame, cv.COLOR_BGR2RGBA) &gt; pilImage = Image.fromarray(cvimage) &gt; pilImage = pilImage.resize((image_width, image_height), Image.ANTIALIAS) &gt; tkImage = ImageTk.PhotoImage(image=pilImage) &gt; return tkImage &gt; &gt; &gt; def button1(): &gt; print(&apos;前&apos;) &gt; s.send(b&apos;3&apos;) &gt; &gt; # 控件定义1 canvas1 = Canvas(top, bg=&apos;white&apos;, width=image_width, height=image_height) # 绘制画布 b1 = Button(top, text=&apos;上&apos;, width=15, &gt; height=2, command=button1) &gt; &gt; # 控件位置设置 canvas1.place(x=imagepos_x1, y=imagepos_y1) b1.place(x=butpos_x1, y=butpos_y1) def button2(): &gt; print(&apos;停&apos;) &gt; s.send(b&apos;0&apos;) &gt; &gt; # 控件定义2 canvas2 = Canvas(top, bg=&apos;white&apos;, width=image_width, height=image_height) # 绘制画布 b2 = Button(top, text=&apos;停&apos;, width=15, &gt; height=2, command=button2) &gt; &gt; # 控件位置设置 canvas2.place(x=imagepos_x2, y=imagepos_y2) b2.place(x=butpos_x2, y=butpos_y2) def button3(): &gt; print(&apos;左&apos;) &gt; s.send(b&apos;2&apos;) &gt; &gt; # 控件定义3 canvas3 = Canvas(top, bg=&apos;white&apos;, width=image_width, height=image_height) # 绘制画布 b3 = Button(top, text=&apos;左&apos;, width=15, &gt; height=2, command=button3) &gt; &gt; # 控件位置设置 canvas3.place(x=imagepos_x3, y=imagepos_y3) b3.place(x=butpos_x3, y=butpos_y3) def button4(): &gt; print(&apos;右&apos;) &gt; s.send(b&apos;1&apos;) &gt; &gt; # 控件定义4 canvas4 = Canvas(top, bg=&apos;white&apos;, width=image_width, height=image_height) # 绘制画布 b4 = Button(top, text=&apos;右&apos;, width=15, &gt; height=2, command=button4) &gt; &gt; # 控件位置设置 canvas4.place(x=imagepos_x4, y=imagepos_y4) b4.place(x=butpos_x4, y=butpos_y4) if __name__ == &quot;__main__&quot;: &gt; while (True): &gt; picture = tkImage() &gt; canvas1.create_image(0, 0, anchor=&apos;nw&apos;, image=picture) &gt; canvas2.create_image(0, 0, anchor=&apos;nw&apos;, image=picture) &gt; canvas3.create_image(0, 0, anchor=&apos;nw&apos;, image=picture) &gt; canvas4.create_image(0, 0, anchor=&apos;nw&apos;, image=picture) &gt; top.update() &gt; top.after(100) &gt; &gt; top.mainloop() &gt; closecamera()整体演示效果可以在我个人bilibili平台上面观看：https://www.bilibili.com/video/av57485389想要更多资料可以进QQ群 864750551 获取视频处理代码公布在github平台：https://github.com/XSYDream/--Python同时在CSDN下载平台：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git上传项目到Github]]></title>
    <url>%2F2019%2F06%2F10%2FGit%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E5%88%B0Github%2F</url>
    <content type="text"><![CDATA[*本文主要讲解上传过程，其他配置过程忽略，详细的git安装以及github使用过程可以查看菜鸟教程以及百度查找！ ** - 首先在github中建立项目仓库（和你的项目同名）填一下仓库名称，Initialize this repository with a README是可选的，建议在创建时选上，可以在后面省一个步骤。填好之后，点Create repository完成仓库的建立 - 克隆仓库到本地 如果是全新的项目没有任何文件，也可以不用克隆仓库，跳过这一步。点开 Git Shell，进入命令行。首先我们先要把 GitHub 上的我们新建的仓库 clone下来。在本地文件里面右键Git Bash here $ git clone https://github.com/XSYDream/Java-Project.git 远程仓库的地址可以在自己的 Github 项目上找到（以我的为例） - 获取远程仓库地址 克隆仓库之后就在文件夹中出现了项目文件夹及文件,进入项目文件夹，对其进行初始化 $ git init 4.上传README文件如果在创建 Github 仓库时没有勾选创建 README.md 文件，则要先创建 README.md 文件，不然上传文件会报错。如果已经勾选，可以跳过此步骤 $ git init $ touch README.md $ git add README.md $ git commit -m ‘first_commit’ $ git remote add origin https://github.com/XSYDream/Java-Project.gi $ git push origin master 5上传项目跟踪项目文件夹中的所有文件和文件夹 $ git add . 输入本次的提交说明，准备提交暂存区中的更改的已跟踪文件，单引号内为说明内容 $ git commit -m ‘first_commit’ 关联远程仓库，添加后，远程库的名字就是 origin，这是 Git 默认的叫法，也可以改成别的，但是 origin 这个名字一看就知道是远程库。 $ git remote add origin https://github.com/jerryhanjj/baike_spider.git 如果关联出现错误 fatal: remote origin already exists，则执行下列语句再进行关联 git remote rm origin 把本地库的所有内容推送到远程库上 $ git push -u origin master 如果在推送时出现错误 error:failed to push som refs to…….，则执行下列语句 git pull origin master 将远程仓库 Github 上的文件拉下来合并之后重新推送上去]]></content>
  </entry>
  <entry>
    <title><![CDATA[博客开门第一篇]]></title>
    <url>%2F2019%2F06%2F10%2F%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%97%A8%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[2019年6月10号，我把自己的博客搭建完成了，之前也搭建过几次，但是因为维护不好以及电脑系统等原因丢弃了。这次吧这个博客搭建起来只要是用来分享我在大学前三年以及后面学习工作上面的经验！我会把我的项目经验以及项目成果都会发布到我的个人网站上面！其中还会有我之前做过的小成品的东西学习搭建个人博客我主要参考以及网友的方法！其实是很容易的1 https://dgsyrc.github.io/2019/02/01/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E%E4%B9%A6%EF%BC%88%E6%8C%87%E5%8C%97%E4%B9%A6%EF%BC%89/#more2 https://blog.csdn.net/sinat_37781304/article/details/82729029其他的可以参考网上的说法]]></content>
  </entry>
</search>
